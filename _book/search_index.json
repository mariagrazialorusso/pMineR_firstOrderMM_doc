[["index.html", "pMineR: First order Markov Model 1 Class Introduction", " pMineR: First order Markov Model PM liquid lab 2023-02-02 1 Class Introduction The firstOrderMarkovModel class is the second one in pMineR that enables process discovery using the FOMM algorithm. The FOMM is an appreciated, in healthcare, PD algorithm, which explores all the traces in the input EL and stores the absolute frequencies between directly subsequent events. It builds an NxN table, where N is the number of kind of events, and each row and column is associated to a specific event. Each cell of the matrix (pi,j) contains the probability to move, from the event associated at the line i to the event associated to the column j. The class allows the matrix to be easily represented with a Direct Follower Graph (DFG). The first step, as usual, is to create an object of the class as follows: objFOMM&lt;-firstOrderMarkovModel() These arguments can be specified in the class constructor method: considerAutoLoop: boolean which indicates if the autoloops have to be admitted. threshold is the minimum value that a probability should have to do not be set to zero, in the transition matrix. The constructor method of the class requires these two parameters to be entered as items of a list, as follows: library(pMineR) param.list&lt;-list() param.list$considerAutoLoop&lt;-FALSE param.list$threshold&lt;-0.02 objFOMM&lt;-firstOrderMarkovModel(parameters.list = param.list) The following step is to load the event Log through the loadDataset() function. This function requires as input the output of the getData() function from the DataLoader calss: objDL&lt;-dataLoader() objDL$load.csv(nomeFile = &quot;EventLog1.csv&quot;,IDName = &quot;ID&quot;,EVENTName= &quot;Event&quot;,dateColumnName=&quot;Date&quot;,format.column.date = &quot;%Y-%m-%d&quot;,quote = &quot;,&quot;) obj.out&lt;-objDL$getData() objFOMM$loadDataset(dataList = obj.out) "],["train-and-get-the-model-trainmodel-and-getmodel-functions.html", "2 Train and get the Model: trainModel() and getModel() functions", " 2 Train and get the Model: trainModel() and getModel() functions In order to display the DFG, it is necessary at first to call the trainModel() function. This function enables the creation of the NxN matrix, which, as we discussed in the preceding section, provides the basis for the creation of the graph. objFOMM$trainModel() After doing so, we can use the getModel() function, which returns the trained internal FOMM model in terms of: DFG; MMatrix: the matrix containing the number of cases, from the event associated at the line i to the event associated to the column j; MMatrix.perc: the matrix containing the probability to move, from the event associated at the line i to the event associated to the column j. You must specify the kind of output by the kindOfOutput input, which allows the following values: grViz for the DFG. MMatrix MMatrix.perc objFOMM$getModel(kindOfOutput =&quot;MMatrix&quot; ) ## BEGIN END Medical Visit Biopsy total resection MedicalVisit death ## BEGIN 0 0 53 0 0 0 0 ## END 0 0 0 0 0 0 0 ## Medical Visit 0 0 0 52 0 0 9 ## Biopsy 0 0 0 0 37 0 4 ## total resection 0 0 0 0 0 13 11 ## MedicalVisit 0 12 0 0 0 0 40 ## death 0 88 0 0 0 0 0 ## chemotherapy 0 0 0 0 0 6 0 ## Imaging 0 0 64 37 0 0 0 ## partial resection 0 0 0 0 0 14 21 ## radiotherapy 0 0 0 0 0 19 0 ## chemotherapy Imaging partial resection radiotherapy ## BEGIN 0 47 0 0 ## END 0 0 0 0 ## Medical Visit 0 56 0 0 ## Biopsy 0 0 48 0 ## total resection 10 0 0 3 ## MedicalVisit 0 0 0 0 ## death 0 0 0 0 ## chemotherapy 0 0 0 15 ## Imaging 0 0 0 0 ## partial resection 11 0 0 2 ## radiotherapy 0 0 0 0 objFOMM$getModel(kindOfOutput =&quot;MMatrix.perc&quot;) ## BEGIN END Medical Visit Biopsy total resection ## BEGIN 0 0.0000000 0.5300000 0.0000000 0.0000000 ## END 0 0.0000000 0.0000000 0.0000000 0.0000000 ## Medical Visit 0 0.0000000 0.0000000 0.4444444 0.0000000 ## Biopsy 0 0.0000000 0.0000000 0.0000000 0.4157303 ## total resection 0 0.0000000 0.0000000 0.0000000 0.0000000 ## MedicalVisit 0 0.2307692 0.0000000 0.0000000 0.0000000 ## death 0 1.0000000 0.0000000 0.0000000 0.0000000 ## chemotherapy 0 0.0000000 0.0000000 0.0000000 0.0000000 ## Imaging 0 0.0000000 0.6336634 0.3663366 0.0000000 ## partial resection 0 0.0000000 0.0000000 0.0000000 0.0000000 ## radiotherapy 0 0.0000000 0.0000000 0.0000000 0.0000000 ## MedicalVisit death chemotherapy Imaging partial resection ## BEGIN 0.0000000 0.00000000 0.0000000 0.4700000 0.0000000 ## END 0.0000000 0.00000000 0.0000000 0.0000000 0.0000000 ## Medical Visit 0.0000000 0.07692308 0.0000000 0.4786325 0.0000000 ## Biopsy 0.0000000 0.04494382 0.0000000 0.0000000 0.5393258 ## total resection 0.3513514 0.29729730 0.2702703 0.0000000 0.0000000 ## MedicalVisit 0.0000000 0.76923077 0.0000000 0.0000000 0.0000000 ## death 0.0000000 0.00000000 0.0000000 0.0000000 0.0000000 ## chemotherapy 0.2857143 0.00000000 0.0000000 0.0000000 0.0000000 ## Imaging 0.0000000 0.00000000 0.0000000 0.0000000 0.0000000 ## partial resection 0.2916667 0.43750000 0.2291667 0.0000000 0.0000000 ## radiotherapy 1.0000000 0.00000000 0.0000000 0.0000000 0.0000000 ## radiotherapy ## BEGIN 0.00000000 ## END 0.00000000 ## Medical Visit 0.00000000 ## Biopsy 0.00000000 ## total resection 0.08108108 ## MedicalVisit 0.00000000 ## death 0.00000000 ## chemotherapy 0.71428571 ## Imaging 0.00000000 ## partial resection 0.04166667 ## radiotherapy 0.00000000 DFG&lt;-objFOMM$getModel(kindOfOutput =&quot;grViz&quot;) library(DiagrammeR) grViz(DFG) The plot() function can be used as an alternative to the getModel(kindOfOutput=grViz) method: script&lt;-objFOMM$plot(giveItBack = T) grViz(script) "],["survival-analysis-kaplanmeier-and-logranktest-function.html", "3 Survival Analysis: KaplanMeier() and LogRankTest() function", " 3 Survival Analysis: KaplanMeier() and LogRankTest() function The fomm class also contains methods for performing the Survival Analysis. The first of these functions is KaplanMeier() function, which builds a Kaplan Meier curve through an indicated pathway that the user enters by the function inputs. Specifically, the the function arguments are: fromState: first event of the pathway; toState: last event of the pathway; passingThrough: array containing the events labels that should be included in the pathay; passingNotThrough: array containing the events labels that should NOT be included in the pathay; PDV: array representing the event(s) the case must experience in order to become censored withPatientID: array which allows to filter by case-ID UM: time unit (default: mins, possible values: mins,hours,days,weeks,months) survival.list&lt;-objFOMM$KaplanMeier(fromState = &quot;Medical Visit&quot;, toState = &quot;death&quot;, passingThrough = &quot;partial resection&quot;, PDVAt = &quot;MedicalVisit&quot;, UM = &quot;weeks&quot;) s1 &lt;- survfit(Surv(time, outcome) ~ 1, data = survival.list$table) survminer::ggsurvplot(s1) #also: survminer::ggsurvplot(survival.list$KM,data = survival.list$table) survival.list2&lt;-objFOMM$KaplanMeier(fromState = &quot;Medical Visit&quot;, toState = &quot;chemotherapy&quot;, passingThrough = &quot;partial resection&quot;, PDVAt = &quot;MedicalVisit&quot;, UM = &quot;weeks&quot;) s2 &lt;- survfit(Surv(time, outcome) ~ 1, data = survival.list2$table) survminer::ggsurvplot(s1,palette = &quot;blue&quot;) It is possible to compare two Kaplan Meier through a Log Rank test by the LogRankTest() function: log.out&lt;-objFOMM$LogRankTest(KM1 = survival.list,KM2 = survival.list2) log.out$survdiff ## Call: ## survdiff(formula = Surv(time, outcome) ~ KM, data = new.df) ## ## N Observed Expected (O-E)^2/E (O-E)^2/V ## KM=KM1 43 22 20.4 0.126 0.371 ## KM=KM2 22 9 10.6 0.243 0.371 ## ## Chisq= 0.4 on 1 degrees of freedom, p= 0.5 new.df &lt;- rbind(survival.list$table,survival.list2$table) new.df$KM &lt;- c(rep(&quot;KM1&quot;,nrow(survival.list$table) ),rep(&quot;KM2&quot;,nrow(survival.list2$table) )) survminer::ggsurvplot(fit = log.out$survfit,data = new.df,conf.int = T) "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
